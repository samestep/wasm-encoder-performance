// Control instructions.
Unreachable => {
    sink.push(0x00);
}
Nop => {
    sink.push(0x01);
}
Block(bt) => {
    sink.push(0x02);
    bt.encode(sink);
}
Loop(bt) => {
    sink.push(0x03);
    bt.encode(sink);
}
If(bt) => {
    sink.push(0x04);
    bt.encode(sink);
}
Else => {
    sink.push(0x05);
}
Try(bt) => {
    sink.push(0x06);
    bt.encode(sink);
}
Catch(t) => {
    sink.push(0x07);
    t.encode(sink);
}
Throw(t) => {
    sink.push(0x08);
    t.encode(sink);
}
Rethrow(l) => {
    sink.push(0x09);
    l.encode(sink);
}
ThrowRef => {
    sink.push(0x0A);
}
End => {
    sink.push(0x0B);
}
Br(l) => {
    sink.push(0x0C);
    l.encode(sink);
}
BrIf(l) => {
    sink.push(0x0D);
    l.encode(sink);
}
BrTable(ref ls, l) => {
    sink.push(0x0E);
    ls.encode(sink);
    l.encode(sink);
}
BrOnNull(l) => {
    sink.push(0xD5);
    l.encode(sink);
}
BrOnNonNull(l) => {
    sink.push(0xD6);
    l.encode(sink);
}
Return => {
    sink.push(0x0F);
}
Call(f) => {
    sink.push(0x10);
    f.encode(sink);
}
CallRef(ty) => {
    sink.push(0x14);
    ty.encode(sink);
}
CallIndirect { type_index, table_index } => {
    sink.push(0x11);
    type_index.encode(sink);
    table_index.encode(sink);
}
ReturnCallRef(ty) => {
    sink.push(0x15);
    ty.encode(sink);
}

ReturnCall(f) => {
    sink.push(0x12);
    f.encode(sink);
}
ReturnCallIndirect { type_index, table_index } => {
    sink.push(0x13);
    type_index.encode(sink);
    table_index.encode(sink);
}
Delegate(l) => {
    sink.push(0x18);
    l.encode(sink);
}
CatchAll => {
    sink.push(0x19);
}

// Parametric instructions.
Drop => {
    sink.push(0x1A);
}
Select => {
    sink.push(0x1B);
}
TypedSelect(ty) => {
    sink.push(0x1c);
    [ty].encode(sink);
}

TryTable(ty, ref catches) => {
    sink.push(0x1f);
    ty.encode(sink);
    catches.encode(sink);
}

// Variable instructions.
LocalGet(l) => {
    sink.push(0x20);
    l.encode(sink);
}
LocalSet(l) => {
    sink.push(0x21);
    l.encode(sink);
}
LocalTee(l) => {
    sink.push(0x22);
    l.encode(sink);
}
GlobalGet(g) => {
    sink.push(0x23);
    g.encode(sink);
}
GlobalSet(g) => {
    sink.push(0x24);
    g.encode(sink);
}
TableGet(table) => {
    sink.push(0x25);
    table.encode(sink);
}
TableSet(table) => {
    sink.push(0x26);
    table.encode(sink);
}

// Memory instructions.
I32Load(m) => {
    sink.push(0x28);
    m.encode(sink);
}
I64Load(m) => {
    sink.push(0x29);
    m.encode(sink);
}
F32Load(m) => {
    sink.push(0x2A);
    m.encode(sink);
}
F64Load(m) => {
    sink.push(0x2B);
    m.encode(sink);
}
I32Load8S(m) => {
    sink.push(0x2C);
    m.encode(sink);
}
I32Load8U(m) => {
    sink.push(0x2D);
    m.encode(sink);
}
I32Load16S(m) => {
    sink.push(0x2E);
    m.encode(sink);
}
I32Load16U(m) => {
    sink.push(0x2F);
    m.encode(sink);
}
I64Load8S(m) => {
    sink.push(0x30);
    m.encode(sink);
}
I64Load8U(m) => {
    sink.push(0x31);
    m.encode(sink);
}
I64Load16S(m) => {
    sink.push(0x32);
    m.encode(sink);
}
I64Load16U(m) => {
    sink.push(0x33);
    m.encode(sink);
}
I64Load32S(m) => {
    sink.push(0x34);
    m.encode(sink);
}
I64Load32U(m) => {
    sink.push(0x35);
    m.encode(sink);
}
I32Store(m) => {
    sink.push(0x36);
    m.encode(sink);
}
I64Store(m) => {
    sink.push(0x37);
    m.encode(sink);
}
F32Store(m) => {
    sink.push(0x38);
    m.encode(sink);
}
F64Store(m) => {
    sink.push(0x39);
    m.encode(sink);
}
I32Store8(m) => {
    sink.push(0x3A);
    m.encode(sink);
}
I32Store16(m) => {
    sink.push(0x3B);
    m.encode(sink);
}
I64Store8(m) => {
    sink.push(0x3C);
    m.encode(sink);
}
I64Store16(m) => {
    sink.push(0x3D);
    m.encode(sink);
}
I64Store32(m) => {
    sink.push(0x3E);
    m.encode(sink);
}
MemorySize(i) => {
    sink.push(0x3F);
    i.encode(sink);
}
MemoryGrow(i) => {
    sink.push(0x40);
    i.encode(sink);
}
MemoryInit { mem, data_index } => {
    sink.push(0xfc);
    sink.push(0x08);
    data_index.encode(sink);
    mem.encode(sink);
}
DataDrop(data) => {
    sink.push(0xfc);
    sink.push(0x09);
    data.encode(sink);
}
MemoryCopy { src_mem, dst_mem } => {
    sink.push(0xfc);
    sink.push(0x0a);
    dst_mem.encode(sink);
    src_mem.encode(sink);
}
MemoryFill(mem) => {
    sink.push(0xfc);
    sink.push(0x0b);
    mem.encode(sink);
}
MemoryDiscard(mem) => {
    sink.push(0xfc);
    sink.push(0x12);
    mem.encode(sink);
}

// Numeric instructions.
I32Const(x) => {
    sink.push(0x41);
    x.encode(sink);
}
I64Const(x) => {
    sink.push(0x42);
    x.encode(sink);
}
F32Const(x) => {
    sink.push(0x43);
    let x = x.to_bits();
    sink.extend(x.to_le_bytes().iter().copied());
}
F64Const(x) => {
    sink.push(0x44);
    let x = x.to_bits();
    sink.extend(x.to_le_bytes().iter().copied());
}
I32Eqz => {
    sink.push(0x45);
}
I32Eq => {
    sink.push(0x46);
}
I32Ne => {
    sink.push(0x47);
}
I32LtS => {
    sink.push(0x48);
}
I32LtU => {
    sink.push(0x49);
}
I32GtS => {
    sink.push(0x4A);
}
I32GtU => {
    sink.push(0x4B);
}
I32LeS => {
    sink.push(0x4C);
}
I32LeU => {
    sink.push(0x4D);
}
I32GeS => {
    sink.push(0x4E);
}
I32GeU => {
    sink.push(0x4F);
}
I64Eqz => {
    sink.push(0x50);
}
I64Eq => {
    sink.push(0x51);
}
I64Ne => {
    sink.push(0x52);
}
I64LtS => {
    sink.push(0x53);
}
I64LtU => {
    sink.push(0x54);
}
I64GtS => {
    sink.push(0x55);
}
I64GtU => {
    sink.push(0x56);
}
I64LeS => {
    sink.push(0x57);
}
I64LeU => {
    sink.push(0x58);
}
I64GeS => {
    sink.push(0x59);
}
I64GeU => {
    sink.push(0x5A);
}
F32Eq => {
    sink.push(0x5B);
}
F32Ne => {
    sink.push(0x5C);
}
F32Lt => {
    sink.push(0x5D);
}
F32Gt => {
    sink.push(0x5E);
}
F32Le => {
    sink.push(0x5F);
}
F32Ge => {
    sink.push(0x60);
}
F64Eq => {
    sink.push(0x61);
}
F64Ne => {
    sink.push(0x62);
}
F64Lt => {
    sink.push(0x63);
}
F64Gt => {
    sink.push(0x64);
}
F64Le => {
    sink.push(0x65);
}
F64Ge => {
    sink.push(0x66);
}
I32Clz => {
    sink.push(0x67);
}
I32Ctz => {
    sink.push(0x68);
}
I32Popcnt => {
    sink.push(0x69);
}
I32Add => {
    sink.push(0x6A);
}
I32Sub => {
    sink.push(0x6B);
}
I32Mul => {
    sink.push(0x6C);
}
I32DivS => {
    sink.push(0x6D);
}
I32DivU => {
    sink.push(0x6E);
}
I32RemS => {
    sink.push(0x6F);
}
I32RemU => {
    sink.push(0x70);
}
I32And => {
    sink.push(0x71);
}
I32Or => {
    sink.push(0x72);
}
I32Xor => {
    sink.push(0x73);
}
I32Shl => {
    sink.push(0x74);
}
I32ShrS => {
    sink.push(0x75);
}
I32ShrU => {
    sink.push(0x76);
}
I32Rotl => {
    sink.push(0x77);
}
I32Rotr => {
    sink.push(0x78);
}
I64Clz => {
    sink.push(0x79);
}
I64Ctz => {
    sink.push(0x7A);
}
I64Popcnt => {
    sink.push(0x7B);
}
I64Add => {
    sink.push(0x7C);
}
I64Sub => {
    sink.push(0x7D);
}
I64Mul => {
    sink.push(0x7E);
}
I64DivS => {
    sink.push(0x7F);
}
I64DivU => {
    sink.push(0x80);
}
I64RemS => {
    sink.push(0x81);
}
I64RemU => {
    sink.push(0x82);
}
I64And => {
    sink.push(0x83);
}
I64Or => {
    sink.push(0x84);
}
I64Xor => {
    sink.push(0x85);
}
I64Shl => {
    sink.push(0x86);
}
I64ShrS => {
    sink.push(0x87);
}
I64ShrU => {
    sink.push(0x88);
}
I64Rotl => {
    sink.push(0x89);
}
I64Rotr => {
    sink.push(0x8A);
}
F32Abs => {
    sink.push(0x8B);
}
F32Neg => {
    sink.push(0x8C);
}
F32Ceil => {
    sink.push(0x8D);
}
F32Floor => {
    sink.push(0x8E);
}
F32Trunc => {
    sink.push(0x8F);
}
F32Nearest => {
    sink.push(0x90);
}
F32Sqrt => {
    sink.push(0x91);
}
F32Add => {
    sink.push(0x92);
}
F32Sub => {
    sink.push(0x93);
}
F32Mul => {
    sink.push(0x94);
}
F32Div => {
    sink.push(0x95);
}
F32Min => {
    sink.push(0x96);
}
F32Max => {
    sink.push(0x97);
}
F32Copysign => {
    sink.push(0x98);
}
F64Abs => {
    sink.push(0x99);
}
F64Neg => {
    sink.push(0x9A);
}
F64Ceil => {
    sink.push(0x9B);
}
F64Floor => {
    sink.push(0x9C);
}
F64Trunc => {
    sink.push(0x9D);
}
F64Nearest => {
    sink.push(0x9E);
}
F64Sqrt => {
    sink.push(0x9F);
}
F64Add => {
    sink.push(0xA0);
}
F64Sub => {
    sink.push(0xA1);
}
F64Mul => {
    sink.push(0xA2);
}
F64Div => {
    sink.push(0xA3);
}
F64Min => {
    sink.push(0xA4);
}
F64Max => {
    sink.push(0xA5);
}
F64Copysign => {
    sink.push(0xA6);
}
I32WrapI64 => {
    sink.push(0xA7);
}
I32TruncF32S => {
    sink.push(0xA8);
}
I32TruncF32U => {
    sink.push(0xA9);
}
I32TruncF64S => {
    sink.push(0xAA);
}
I32TruncF64U => {
    sink.push(0xAB);
}
I64ExtendI32S => {
    sink.push(0xAC);
}
I64ExtendI32U => {
    sink.push(0xAD);
}
I64TruncF32S => {
    sink.push(0xAE);
}
I64TruncF32U => {
    sink.push(0xAF);
}
I64TruncF64S => {
    sink.push(0xB0);
}
I64TruncF64U => {
    sink.push(0xB1);
}
F32ConvertI32S => {
    sink.push(0xB2);
}
F32ConvertI32U => {
    sink.push(0xB3);
}
F32ConvertI64S => {
    sink.push(0xB4);
}
F32ConvertI64U => {
    sink.push(0xB5);
}
F32DemoteF64 => {
    sink.push(0xB6);
}
F64ConvertI32S => {
    sink.push(0xB7);
}
F64ConvertI32U => {
    sink.push(0xB8);
}
F64ConvertI64S => {
    sink.push(0xB9);
}
F64ConvertI64U => {
    sink.push(0xBA);
}
F64PromoteF32 => {
    sink.push(0xBB);
}
I32ReinterpretF32 => {
    sink.push(0xBC);
}
I64ReinterpretF64 => {
    sink.push(0xBD);
}
F32ReinterpretI32 => {
    sink.push(0xBE);
}
F64ReinterpretI64 => {
    sink.push(0xBF);
}
I32Extend8S => {
    sink.push(0xC0);
}
I32Extend16S => {
    sink.push(0xC1);
}
I64Extend8S => {
    sink.push(0xC2);
}
I64Extend16S => {
    sink.push(0xC3);
}
I64Extend32S => {
    sink.push(0xC4);
}

I32TruncSatF32S => {
    sink.push(0xFC);
    sink.push(0x00);
}
I32TruncSatF32U => {
    sink.push(0xFC);
    sink.push(0x01);
}
I32TruncSatF64S => {
    sink.push(0xFC);
    sink.push(0x02);
}
I32TruncSatF64U => {
    sink.push(0xFC);
    sink.push(0x03);
}
I64TruncSatF32S => {
    sink.push(0xFC);
    sink.push(0x04);
}
I64TruncSatF32U => {
    sink.push(0xFC);
    sink.push(0x05);
}
I64TruncSatF64S => {
    sink.push(0xFC);
    sink.push(0x06);
}
I64TruncSatF64U => {
    sink.push(0xFC);
    sink.push(0x07);
}

// Reference types instructions.
RefNull(ty) => {
    sink.push(0xd0);
    ty.encode(sink);
}
RefIsNull => {
    sink.push(0xd1);
}
RefFunc(f) => {
    sink.push(0xd2);
    f.encode(sink);
}
RefEq => {
    sink.push(0xd3);
}
RefAsNonNull => {
    sink.push(0xd4);
}

// GC instructions.
StructNew(type_index) => {
    sink.push(0xfb);
    sink.push(0x00);
    type_index.encode(sink);
}
StructNewDefault(type_index) => {
    sink.push(0xfb);
    sink.push(0x01);
    type_index.encode(sink);
}
StructGet { struct_type_index, field_index } => {
    sink.push(0xfb);
    sink.push(0x02);
    struct_type_index.encode(sink);
    field_index.encode(sink);
}
StructGetS { struct_type_index, field_index } => {
    sink.push(0xfb);
    sink.push(0x03);
    struct_type_index.encode(sink);
    field_index.encode(sink);
}
StructGetU { struct_type_index, field_index } => {
    sink.push(0xfb);
    sink.push(0x04);
    struct_type_index.encode(sink);
    field_index.encode(sink);
}
StructSet { struct_type_index, field_index } => {
    sink.push(0xfb);
    sink.push(0x05);
    struct_type_index.encode(sink);
    field_index.encode(sink);
}
ArrayNew(type_index) => {
    sink.push(0xfb);
    sink.push(0x06);
    type_index.encode(sink);
}
ArrayNewDefault(type_index) => {
    sink.push(0xfb);
    sink.push(0x07);
    type_index.encode(sink);
}
ArrayNewFixed { array_type_index, array_size } => {
    sink.push(0xfb);
    sink.push(0x08);
    array_type_index.encode(sink);
    array_size.encode(sink);
}
ArrayNewData { array_type_index, array_data_index } => {
    sink.push(0xfb);
    sink.push(0x09);
    array_type_index.encode(sink);
    array_data_index.encode(sink);
}
ArrayNewElem { array_type_index, array_elem_index } => {
    sink.push(0xfb);
    sink.push(0x0a);
    array_type_index.encode(sink);
    array_elem_index.encode(sink);
}
ArrayGet(type_index) => {
    sink.push(0xfb);
    sink.push(0x0b);
    type_index.encode(sink);
}
ArrayGetS(type_index) => {
    sink.push(0xfb);
    sink.push(0x0c);
    type_index.encode(sink);
}
ArrayGetU(type_index) => {
    sink.push(0xfb);
    sink.push(0x0d);
    type_index.encode(sink);
}
ArraySet(type_index) => {
    sink.push(0xfb);
    sink.push(0x0e);
    type_index.encode(sink);
}
ArrayLen => {
    sink.push(0xfb);
    sink.push(0x0f);
}
ArrayFill(type_index) => {
    sink.push(0xfb);
    sink.push(0x10);
    type_index.encode(sink);
}
ArrayCopy { array_type_index_dst, array_type_index_src } => {
    sink.push(0xfb);
    sink.push(0x11);
    array_type_index_dst.encode(sink);
    array_type_index_src.encode(sink);
}
ArrayInitData { array_type_index, array_data_index } => {
    sink.push(0xfb);
    sink.push(0x12);
    array_type_index.encode(sink);
    array_data_index.encode(sink);
}
ArrayInitElem { array_type_index, array_elem_index } => {
    sink.push(0xfb);
    sink.push(0x13);
    array_type_index.encode(sink);
    array_elem_index.encode(sink);
}
RefTestNonNull(heap_type) => {
    sink.push(0xfb);
    sink.push(0x14);
    heap_type.encode(sink);
}
RefTestNullable(heap_type) => {
    sink.push(0xfb);
    sink.push(0x15);
    heap_type.encode(sink);
}
RefCastNonNull(heap_type) => {
    sink.push(0xfb);
    sink.push(0x16);
    heap_type.encode(sink);
}
RefCastNullable(heap_type) => {
    sink.push(0xfb);
    sink.push(0x17);
    heap_type.encode(sink);
}
BrOnCast { relative_depth, from_ref_type, to_ref_type } => {
    sink.push(0xfb);
    sink.push(0x18);
    let cast_flags =
        (from_ref_type.nullable as u8) | ((to_ref_type.nullable as u8) << 1);
    sink.push(cast_flags);
    relative_depth.encode(sink);
    from_ref_type.heap_type.encode(sink);
    to_ref_type.heap_type.encode(sink);
}
BrOnCastFail { relative_depth, from_ref_type, to_ref_type } => {
    sink.push(0xfb);
    sink.push(0x19);
    let cast_flags =
        (from_ref_type.nullable as u8) | ((to_ref_type.nullable as u8) << 1);
    sink.push(cast_flags);
    relative_depth.encode(sink);
    from_ref_type.heap_type.encode(sink);
    to_ref_type.heap_type.encode(sink);
}
AnyConvertExtern => {
    sink.push(0xfb);
    sink.push(0x1a);
}
ExternConvertAny => {
    sink.push(0xfb);
    sink.push(0x1b);
}
RefI31 => {
    sink.push(0xfb);
    sink.push(0x1c);
}
I31GetS => {
    sink.push(0xfb);
    sink.push(0x1d);
}
I31GetU => {
    sink.push(0xfb);
    sink.push(0x1e);
}

// Bulk memory instructions.
TableInit { elem_index, table } => {
    sink.push(0xfc);
    sink.push(0x0c);
    elem_index.encode(sink);
    table.encode(sink);
}
ElemDrop(segment) => {
    sink.push(0xfc);
    sink.push(0x0d);
    segment.encode(sink);
}
TableCopy { src_table, dst_table } => {
    sink.push(0xfc);
    sink.push(0x0e);
    dst_table.encode(sink);
    src_table.encode(sink);
}
TableGrow(table) => {
    sink.push(0xfc);
    sink.push(0x0f);
    table.encode(sink);
}
TableSize(table) => {
    sink.push(0xfc);
    sink.push(0x10);
    table.encode(sink);
}
TableFill(table) => {
    sink.push(0xfc);
    sink.push(0x11);
    table.encode(sink);
}

// SIMD instructions.
V128Load(memarg) => {
    sink.push(0xFD);
    0x00u32.encode(sink);
    memarg.encode(sink);
}
V128Load8x8S(memarg) => {
    sink.push(0xFD);
    0x01u32.encode(sink);
    memarg.encode(sink);
}
V128Load8x8U(memarg) => {
    sink.push(0xFD);
    0x02u32.encode(sink);
    memarg.encode(sink);
}
V128Load16x4S(memarg) => {
    sink.push(0xFD);
    0x03u32.encode(sink);
    memarg.encode(sink);
}
V128Load16x4U(memarg) => {
    sink.push(0xFD);
    0x04u32.encode(sink);
    memarg.encode(sink);
}
V128Load32x2S(memarg) => {
    sink.push(0xFD);
    0x05u32.encode(sink);
    memarg.encode(sink);
}
V128Load32x2U(memarg) => {
    sink.push(0xFD);
    0x06u32.encode(sink);
    memarg.encode(sink);
}
V128Load8Splat(memarg) => {
    sink.push(0xFD);
    0x07u32.encode(sink);
    memarg.encode(sink);
}
V128Load16Splat(memarg) => {
    sink.push(0xFD);
    0x08u32.encode(sink);
    memarg.encode(sink);
}
V128Load32Splat(memarg) => {
    sink.push(0xFD);
    0x09u32.encode(sink);
    memarg.encode(sink);
}
V128Load64Splat(memarg) => {
    sink.push(0xFD);
    0x0Au32.encode(sink);
    memarg.encode(sink);
}
V128Store(memarg) => {
    sink.push(0xFD);
    0x0Bu32.encode(sink);
    memarg.encode(sink);
}
V128Const(x) => {
    sink.push(0xFD);
    0x0Cu32.encode(sink);
    sink.extend(x.to_le_bytes().iter().copied());
}
I8x16Shuffle(lanes) => {
    sink.push(0xFD);
    0x0Du32.encode(sink);
    assert!(lanes.iter().all(|l: &u8| *l < 32));
    sink.extend(lanes.iter().copied());
}
I8x16Swizzle => {
    sink.push(0xFD);
    0x0Eu32.encode(sink);
}
I8x16Splat => {
    sink.push(0xFD);
    0x0Fu32.encode(sink);
}
I16x8Splat => {
    sink.push(0xFD);
    0x10u32.encode(sink);
}
I32x4Splat => {
    sink.push(0xFD);
    0x11u32.encode(sink);
}
I64x2Splat => {
    sink.push(0xFD);
    0x12u32.encode(sink);
}
F32x4Splat => {
    sink.push(0xFD);
    0x13u32.encode(sink);
}
F64x2Splat => {
    sink.push(0xFD);
    0x14u32.encode(sink);
}
I8x16ExtractLaneS(lane) => {
    sink.push(0xFD);
    0x15u32.encode(sink);
    assert!(lane < 16);
    sink.push(lane);
}
I8x16ExtractLaneU(lane) => {
    sink.push(0xFD);
    0x16u32.encode(sink);
    assert!(lane < 16);
    sink.push(lane);
}
I8x16ReplaceLane(lane) => {
    sink.push(0xFD);
    0x17u32.encode(sink);
    assert!(lane < 16);
    sink.push(lane);
}
I16x8ExtractLaneS(lane) => {
    sink.push(0xFD);
    0x18u32.encode(sink);
    assert!(lane < 8);
    sink.push(lane);
}
I16x8ExtractLaneU(lane) => {
    sink.push(0xFD);
    0x19u32.encode(sink);
    assert!(lane < 8);
    sink.push(lane);
}
I16x8ReplaceLane(lane) => {
    sink.push(0xFD);
    0x1Au32.encode(sink);
    assert!(lane < 8);
    sink.push(lane);
}
I32x4ExtractLane(lane) => {
    sink.push(0xFD);
    0x1Bu32.encode(sink);
    assert!(lane < 4);
    sink.push(lane);
}
I32x4ReplaceLane(lane) => {
    sink.push(0xFD);
    0x1Cu32.encode(sink);
    assert!(lane < 4);
    sink.push(lane);
}
I64x2ExtractLane(lane) => {
    sink.push(0xFD);
    0x1Du32.encode(sink);
    assert!(lane < 2);
    sink.push(lane);
}
I64x2ReplaceLane(lane) => {
    sink.push(0xFD);
    0x1Eu32.encode(sink);
    assert!(lane < 2);
    sink.push(lane);
}
F32x4ExtractLane(lane) => {
    sink.push(0xFD);
    0x1Fu32.encode(sink);
    assert!(lane < 4);
    sink.push(lane);
}
F32x4ReplaceLane(lane) => {
    sink.push(0xFD);
    0x20u32.encode(sink);
    assert!(lane < 4);
    sink.push(lane);
}
F64x2ExtractLane(lane) => {
    sink.push(0xFD);
    0x21u32.encode(sink);
    assert!(lane < 2);
    sink.push(lane);
}
F64x2ReplaceLane(lane) => {
    sink.push(0xFD);
    0x22u32.encode(sink);
    assert!(lane < 2);
    sink.push(lane);
}

I8x16Eq => {
    sink.push(0xFD);
    0x23u32.encode(sink);
}
I8x16Ne => {
    sink.push(0xFD);
    0x24u32.encode(sink);
}
I8x16LtS => {
    sink.push(0xFD);
    0x25u32.encode(sink);
}
I8x16LtU => {
    sink.push(0xFD);
    0x26u32.encode(sink);
}
I8x16GtS => {
    sink.push(0xFD);
    0x27u32.encode(sink);
}
I8x16GtU => {
    sink.push(0xFD);
    0x28u32.encode(sink);
}
I8x16LeS => {
    sink.push(0xFD);
    0x29u32.encode(sink);
}
I8x16LeU => {
    sink.push(0xFD);
    0x2Au32.encode(sink);
}
I8x16GeS => {
    sink.push(0xFD);
    0x2Bu32.encode(sink);
}
I8x16GeU => {
    sink.push(0xFD);
    0x2Cu32.encode(sink);
}
I16x8Eq => {
    sink.push(0xFD);
    0x2Du32.encode(sink);
}
I16x8Ne => {
    sink.push(0xFD);
    0x2Eu32.encode(sink);
}
I16x8LtS => {
    sink.push(0xFD);
    0x2Fu32.encode(sink);
}
I16x8LtU => {
    sink.push(0xFD);
    0x30u32.encode(sink);
}
I16x8GtS => {
    sink.push(0xFD);
    0x31u32.encode(sink);
}
I16x8GtU => {
    sink.push(0xFD);
    0x32u32.encode(sink);
}
I16x8LeS => {
    sink.push(0xFD);
    0x33u32.encode(sink);
}
I16x8LeU => {
    sink.push(0xFD);
    0x34u32.encode(sink);
}
I16x8GeS => {
    sink.push(0xFD);
    0x35u32.encode(sink);
}
I16x8GeU => {
    sink.push(0xFD);
    0x36u32.encode(sink);
}
I32x4Eq => {
    sink.push(0xFD);
    0x37u32.encode(sink);
}
I32x4Ne => {
    sink.push(0xFD);
    0x38u32.encode(sink);
}
I32x4LtS => {
    sink.push(0xFD);
    0x39u32.encode(sink);
}
I32x4LtU => {
    sink.push(0xFD);
    0x3Au32.encode(sink);
}
I32x4GtS => {
    sink.push(0xFD);
    0x3Bu32.encode(sink);
}
I32x4GtU => {
    sink.push(0xFD);
    0x3Cu32.encode(sink);
}
I32x4LeS => {
    sink.push(0xFD);
    0x3Du32.encode(sink);
}
I32x4LeU => {
    sink.push(0xFD);
    0x3Eu32.encode(sink);
}
I32x4GeS => {
    sink.push(0xFD);
    0x3Fu32.encode(sink);
}
I32x4GeU => {
    sink.push(0xFD);
    0x40u32.encode(sink);
}
F32x4Eq => {
    sink.push(0xFD);
    0x41u32.encode(sink);
}
F32x4Ne => {
    sink.push(0xFD);
    0x42u32.encode(sink);
}
F32x4Lt => {
    sink.push(0xFD);
    0x43u32.encode(sink);
}
F32x4Gt => {
    sink.push(0xFD);
    0x44u32.encode(sink);
}
F32x4Le => {
    sink.push(0xFD);
    0x45u32.encode(sink);
}
F32x4Ge => {
    sink.push(0xFD);
    0x46u32.encode(sink);
}
F64x2Eq => {
    sink.push(0xFD);
    0x47u32.encode(sink);
}
F64x2Ne => {
    sink.push(0xFD);
    0x48u32.encode(sink);
}
F64x2Lt => {
    sink.push(0xFD);
    0x49u32.encode(sink);
}
F64x2Gt => {
    sink.push(0xFD);
    0x4Au32.encode(sink);
}
F64x2Le => {
    sink.push(0xFD);
    0x4Bu32.encode(sink);
}
F64x2Ge => {
    sink.push(0xFD);
    0x4Cu32.encode(sink);
}
V128Not => {
    sink.push(0xFD);
    0x4Du32.encode(sink);
}
V128And => {
    sink.push(0xFD);
    0x4Eu32.encode(sink);
}
V128AndNot => {
    sink.push(0xFD);
    0x4Fu32.encode(sink);
}
V128Or => {
    sink.push(0xFD);
    0x50u32.encode(sink);
}
V128Xor => {
    sink.push(0xFD);
    0x51u32.encode(sink);
}
V128Bitselect => {
    sink.push(0xFD);
    0x52u32.encode(sink);
}
V128AnyTrue => {
    sink.push(0xFD);
    0x53u32.encode(sink);
}
I8x16Abs => {
    sink.push(0xFD);
    0x60u32.encode(sink);
}
I8x16Neg => {
    sink.push(0xFD);
    0x61u32.encode(sink);
}
I8x16Popcnt => {
    sink.push(0xFD);
    0x62u32.encode(sink);
}
I8x16AllTrue => {
    sink.push(0xFD);
    0x63u32.encode(sink);
}
I8x16Bitmask => {
    sink.push(0xFD);
    0x64u32.encode(sink);
}
I8x16NarrowI16x8S => {
    sink.push(0xFD);
    0x65u32.encode(sink);
}
I8x16NarrowI16x8U => {
    sink.push(0xFD);
    0x66u32.encode(sink);
}
I8x16Shl => {
    sink.push(0xFD);
    0x6bu32.encode(sink);
}
I8x16ShrS => {
    sink.push(0xFD);
    0x6cu32.encode(sink);
}
I8x16ShrU => {
    sink.push(0xFD);
    0x6du32.encode(sink);
}
I8x16Add => {
    sink.push(0xFD);
    0x6eu32.encode(sink);
}
I8x16AddSatS => {
    sink.push(0xFD);
    0x6fu32.encode(sink);
}
I8x16AddSatU => {
    sink.push(0xFD);
    0x70u32.encode(sink);
}
I8x16Sub => {
    sink.push(0xFD);
    0x71u32.encode(sink);
}
I8x16SubSatS => {
    sink.push(0xFD);
    0x72u32.encode(sink);
}
I8x16SubSatU => {
    sink.push(0xFD);
    0x73u32.encode(sink);
}
I8x16MinS => {
    sink.push(0xFD);
    0x76u32.encode(sink);
}
I8x16MinU => {
    sink.push(0xFD);
    0x77u32.encode(sink);
}
I8x16MaxS => {
    sink.push(0xFD);
    0x78u32.encode(sink);
}
I8x16MaxU => {
    sink.push(0xFD);
    0x79u32.encode(sink);
}
I8x16AvgrU => {
    sink.push(0xFD);
    0x7Bu32.encode(sink);
}
I16x8ExtAddPairwiseI8x16S => {
    sink.push(0xFD);
    0x7Cu32.encode(sink);
}
I16x8ExtAddPairwiseI8x16U => {
    sink.push(0xFD);
    0x7Du32.encode(sink);
}
I32x4ExtAddPairwiseI16x8S => {
    sink.push(0xFD);
    0x7Eu32.encode(sink);
}
I32x4ExtAddPairwiseI16x8U => {
    sink.push(0xFD);
    0x7Fu32.encode(sink);
}
I16x8Abs => {
    sink.push(0xFD);
    0x80u32.encode(sink);
}
I16x8Neg => {
    sink.push(0xFD);
    0x81u32.encode(sink);
}
I16x8Q15MulrSatS => {
    sink.push(0xFD);
    0x82u32.encode(sink);
}
I16x8AllTrue => {
    sink.push(0xFD);
    0x83u32.encode(sink);
}
I16x8Bitmask => {
    sink.push(0xFD);
    0x84u32.encode(sink);
}
I16x8NarrowI32x4S => {
    sink.push(0xFD);
    0x85u32.encode(sink);
}
I16x8NarrowI32x4U => {
    sink.push(0xFD);
    0x86u32.encode(sink);
}
I16x8ExtendLowI8x16S => {
    sink.push(0xFD);
    0x87u32.encode(sink);
}
I16x8ExtendHighI8x16S => {
    sink.push(0xFD);
    0x88u32.encode(sink);
}
I16x8ExtendLowI8x16U => {
    sink.push(0xFD);
    0x89u32.encode(sink);
}
I16x8ExtendHighI8x16U => {
    sink.push(0xFD);
    0x8Au32.encode(sink);
}
I16x8Shl => {
    sink.push(0xFD);
    0x8Bu32.encode(sink);
}
I16x8ShrS => {
    sink.push(0xFD);
    0x8Cu32.encode(sink);
}
I16x8ShrU => {
    sink.push(0xFD);
    0x8Du32.encode(sink);
}
I16x8Add => {
    sink.push(0xFD);
    0x8Eu32.encode(sink);
}
I16x8AddSatS => {
    sink.push(0xFD);
    0x8Fu32.encode(sink);
}
I16x8AddSatU => {
    sink.push(0xFD);
    0x90u32.encode(sink);
}
I16x8Sub => {
    sink.push(0xFD);
    0x91u32.encode(sink);
}
I16x8SubSatS => {
    sink.push(0xFD);
    0x92u32.encode(sink);
}
I16x8SubSatU => {
    sink.push(0xFD);
    0x93u32.encode(sink);
}
I16x8Mul => {
    sink.push(0xFD);
    0x95u32.encode(sink);
}
I16x8MinS => {
    sink.push(0xFD);
    0x96u32.encode(sink);
}
I16x8MinU => {
    sink.push(0xFD);
    0x97u32.encode(sink);
}
I16x8MaxS => {
    sink.push(0xFD);
    0x98u32.encode(sink);
}
I16x8MaxU => {
    sink.push(0xFD);
    0x99u32.encode(sink);
}
I16x8AvgrU => {
    sink.push(0xFD);
    0x9Bu32.encode(sink);
}
I16x8ExtMulLowI8x16S => {
    sink.push(0xFD);
    0x9Cu32.encode(sink);
}
I16x8ExtMulHighI8x16S => {
    sink.push(0xFD);
    0x9Du32.encode(sink);
}
I16x8ExtMulLowI8x16U => {
    sink.push(0xFD);
    0x9Eu32.encode(sink);
}
I16x8ExtMulHighI8x16U => {
    sink.push(0xFD);
    0x9Fu32.encode(sink);
}
I32x4Abs => {
    sink.push(0xFD);
    0xA0u32.encode(sink);
}
I32x4Neg => {
    sink.push(0xFD);
    0xA1u32.encode(sink);
}
I32x4AllTrue => {
    sink.push(0xFD);
    0xA3u32.encode(sink);
}
I32x4Bitmask => {
    sink.push(0xFD);
    0xA4u32.encode(sink);
}
I32x4ExtendLowI16x8S => {
    sink.push(0xFD);
    0xA7u32.encode(sink);
}
I32x4ExtendHighI16x8S => {
    sink.push(0xFD);
    0xA8u32.encode(sink);
}
I32x4ExtendLowI16x8U => {
    sink.push(0xFD);
    0xA9u32.encode(sink);
}
I32x4ExtendHighI16x8U => {
    sink.push(0xFD);
    0xAAu32.encode(sink);
}
I32x4Shl => {
    sink.push(0xFD);
    0xABu32.encode(sink);
}
I32x4ShrS => {
    sink.push(0xFD);
    0xACu32.encode(sink);
}
I32x4ShrU => {
    sink.push(0xFD);
    0xADu32.encode(sink);
}
I32x4Add => {
    sink.push(0xFD);
    0xAEu32.encode(sink);
}
I32x4Sub => {
    sink.push(0xFD);
    0xB1u32.encode(sink);
}
I32x4Mul => {
    sink.push(0xFD);
    0xB5u32.encode(sink);
}
I32x4MinS => {
    sink.push(0xFD);
    0xB6u32.encode(sink);
}
I32x4MinU => {
    sink.push(0xFD);
    0xB7u32.encode(sink);
}
I32x4MaxS => {
    sink.push(0xFD);
    0xB8u32.encode(sink);
}
I32x4MaxU => {
    sink.push(0xFD);
    0xB9u32.encode(sink);
}
I32x4DotI16x8S => {
    sink.push(0xFD);
    0xBAu32.encode(sink);
}
I32x4ExtMulLowI16x8S => {
    sink.push(0xFD);
    0xBCu32.encode(sink);
}
I32x4ExtMulHighI16x8S => {
    sink.push(0xFD);
    0xBDu32.encode(sink);
}
I32x4ExtMulLowI16x8U => {
    sink.push(0xFD);
    0xBEu32.encode(sink);
}
I32x4ExtMulHighI16x8U => {
    sink.push(0xFD);
    0xBFu32.encode(sink);
}
I64x2Abs => {
    sink.push(0xFD);
    0xC0u32.encode(sink);
}
I64x2Neg => {
    sink.push(0xFD);
    0xC1u32.encode(sink);
}
I64x2AllTrue => {
    sink.push(0xFD);
    0xC3u32.encode(sink);
}
I64x2Bitmask => {
    sink.push(0xFD);
    0xC4u32.encode(sink);
}
I64x2ExtendLowI32x4S => {
    sink.push(0xFD);
    0xC7u32.encode(sink);
}
I64x2ExtendHighI32x4S => {
    sink.push(0xFD);
    0xC8u32.encode(sink);
}
I64x2ExtendLowI32x4U => {
    sink.push(0xFD);
    0xC9u32.encode(sink);
}
I64x2ExtendHighI32x4U => {
    sink.push(0xFD);
    0xCAu32.encode(sink);
}
I64x2Shl => {
    sink.push(0xFD);
    0xCBu32.encode(sink);
}
I64x2ShrS => {
    sink.push(0xFD);
    0xCCu32.encode(sink);
}
I64x2ShrU => {
    sink.push(0xFD);
    0xCDu32.encode(sink);
}
I64x2Add => {
    sink.push(0xFD);
    0xCEu32.encode(sink);
}
I64x2Sub => {
    sink.push(0xFD);
    0xD1u32.encode(sink);
}
I64x2Mul => {
    sink.push(0xFD);
    0xD5u32.encode(sink);
}
I64x2ExtMulLowI32x4S => {
    sink.push(0xFD);
    0xDCu32.encode(sink);
}
I64x2ExtMulHighI32x4S => {
    sink.push(0xFD);
    0xDDu32.encode(sink);
}
I64x2ExtMulLowI32x4U => {
    sink.push(0xFD);
    0xDEu32.encode(sink);
}
I64x2ExtMulHighI32x4U => {
    sink.push(0xFD);
    0xDFu32.encode(sink);
}
F32x4Ceil => {
    sink.push(0xFD);
    0x67u32.encode(sink);
}
F32x4Floor => {
    sink.push(0xFD);
    0x68u32.encode(sink);
}
F32x4Trunc => {
    sink.push(0xFD);
    0x69u32.encode(sink);
}
F32x4Nearest => {
    sink.push(0xFD);
    0x6Au32.encode(sink);
}
F32x4Abs => {
    sink.push(0xFD);
    0xE0u32.encode(sink);
}
F32x4Neg => {
    sink.push(0xFD);
    0xE1u32.encode(sink);
}
F32x4Sqrt => {
    sink.push(0xFD);
    0xE3u32.encode(sink);
}
F32x4Add => {
    sink.push(0xFD);
    0xE4u32.encode(sink);
}
F32x4Sub => {
    sink.push(0xFD);
    0xE5u32.encode(sink);
}
F32x4Mul => {
    sink.push(0xFD);
    0xE6u32.encode(sink);
}
F32x4Div => {
    sink.push(0xFD);
    0xE7u32.encode(sink);
}
F32x4Min => {
    sink.push(0xFD);
    0xE8u32.encode(sink);
}
F32x4Max => {
    sink.push(0xFD);
    0xE9u32.encode(sink);
}
F32x4PMin => {
    sink.push(0xFD);
    0xEAu32.encode(sink);
}
F32x4PMax => {
    sink.push(0xFD);
    0xEBu32.encode(sink);
}
F64x2Ceil => {
    sink.push(0xFD);
    0x74u32.encode(sink);
}
F64x2Floor => {
    sink.push(0xFD);
    0x75u32.encode(sink);
}
F64x2Trunc => {
    sink.push(0xFD);
    0x7Au32.encode(sink);
}
F64x2Nearest => {
    sink.push(0xFD);
    0x94u32.encode(sink);
}
F64x2Abs => {
    sink.push(0xFD);
    0xECu32.encode(sink);
}
F64x2Neg => {
    sink.push(0xFD);
    0xEDu32.encode(sink);
}
F64x2Sqrt => {
    sink.push(0xFD);
    0xEFu32.encode(sink);
}
F64x2Add => {
    sink.push(0xFD);
    0xF0u32.encode(sink);
}
F64x2Sub => {
    sink.push(0xFD);
    0xF1u32.encode(sink);
}
F64x2Mul => {
    sink.push(0xFD);
    0xF2u32.encode(sink);
}
F64x2Div => {
    sink.push(0xFD);
    0xF3u32.encode(sink);
}
F64x2Min => {
    sink.push(0xFD);
    0xF4u32.encode(sink);
}
F64x2Max => {
    sink.push(0xFD);
    0xF5u32.encode(sink);
}
F64x2PMin => {
    sink.push(0xFD);
    0xF6u32.encode(sink);
}
F64x2PMax => {
    sink.push(0xFD);
    0xF7u32.encode(sink);
}
I32x4TruncSatF32x4S => {
    sink.push(0xFD);
    0xF8u32.encode(sink);
}
I32x4TruncSatF32x4U => {
    sink.push(0xFD);
    0xF9u32.encode(sink);
}
F32x4ConvertI32x4S => {
    sink.push(0xFD);
    0xFAu32.encode(sink);
}
F32x4ConvertI32x4U => {
    sink.push(0xFD);
    0xFBu32.encode(sink);
}
I32x4TruncSatF64x2SZero => {
    sink.push(0xFD);
    0xFCu32.encode(sink);
}
I32x4TruncSatF64x2UZero => {
    sink.push(0xFD);
    0xFDu32.encode(sink);
}
F64x2ConvertLowI32x4S => {
    sink.push(0xFD);
    0xFEu32.encode(sink);
}
F64x2ConvertLowI32x4U => {
    sink.push(0xFD);
    0xFFu32.encode(sink);
}
F32x4DemoteF64x2Zero => {
    sink.push(0xFD);
    0x5Eu32.encode(sink);
}
F64x2PromoteLowF32x4 => {
    sink.push(0xFD);
    0x5Fu32.encode(sink);
}
V128Load32Zero(memarg) => {
    sink.push(0xFD);
    0x5Cu32.encode(sink);
    memarg.encode(sink);
}
V128Load64Zero(memarg) => {
    sink.push(0xFD);
    0x5Du32.encode(sink);
    memarg.encode(sink);
}
V128Load8Lane { memarg, lane } => {
    sink.push(0xFD);
    0x54u32.encode(sink);
    memarg.encode(sink);
    assert!(lane < 16);
    sink.push(lane);
}
V128Load16Lane { memarg, lane } => {
    sink.push(0xFD);
    0x55u32.encode(sink);
    memarg.encode(sink);
    assert!(lane < 8);
    sink.push(lane);
}
V128Load32Lane { memarg, lane } => {
    sink.push(0xFD);
    0x56u32.encode(sink);
    memarg.encode(sink);
    assert!(lane < 4);
    sink.push(lane);
}
V128Load64Lane { memarg, lane } => {
    sink.push(0xFD);
    0x57u32.encode(sink);
    memarg.encode(sink);
    assert!(lane < 2);
    sink.push(lane);
}
V128Store8Lane { memarg, lane } => {
    sink.push(0xFD);
    0x58u32.encode(sink);
    memarg.encode(sink);
    assert!(lane < 16);
    sink.push(lane);
}
V128Store16Lane { memarg, lane } => {
    sink.push(0xFD);
    0x59u32.encode(sink);
    memarg.encode(sink);
    assert!(lane < 8);
    sink.push(lane);
}
V128Store32Lane { memarg, lane } => {
    sink.push(0xFD);
    0x5Au32.encode(sink);
    memarg.encode(sink);
    assert!(lane < 4);
    sink.push(lane);
}
V128Store64Lane { memarg, lane } => {
    sink.push(0xFD);
    0x5Bu32.encode(sink);
    memarg.encode(sink);
    assert!(lane < 2);
    sink.push(lane);
}
I64x2Eq => {
    sink.push(0xFD);
    0xD6u32.encode(sink);
}
I64x2Ne => {
    sink.push(0xFD);
    0xD7u32.encode(sink);
}
I64x2LtS => {
    sink.push(0xFD);
    0xD8u32.encode(sink);
}
I64x2GtS => {
    sink.push(0xFD);
    0xD9u32.encode(sink);
}
I64x2LeS => {
    sink.push(0xFD);
    0xDAu32.encode(sink);
}
I64x2GeS => {
    sink.push(0xFD);
    0xDBu32.encode(sink);
}
I8x16RelaxedSwizzle => {
    sink.push(0xFD);
    0x100u32.encode(sink);
}
I32x4RelaxedTruncF32x4S => {
    sink.push(0xFD);
    0x101u32.encode(sink);
}
I32x4RelaxedTruncF32x4U => {
    sink.push(0xFD);
    0x102u32.encode(sink);
}
I32x4RelaxedTruncF64x2SZero => {
    sink.push(0xFD);
    0x103u32.encode(sink);
}
I32x4RelaxedTruncF64x2UZero => {
    sink.push(0xFD);
    0x104u32.encode(sink);
}
F32x4RelaxedMadd => {
    sink.push(0xFD);
    0x105u32.encode(sink);
}
F32x4RelaxedNmadd => {
    sink.push(0xFD);
    0x106u32.encode(sink);
}
F64x2RelaxedMadd => {
    sink.push(0xFD);
    0x107u32.encode(sink);
}
F64x2RelaxedNmadd => {
    sink.push(0xFD);
    0x108u32.encode(sink);
}
I8x16RelaxedLaneselect => {
    sink.push(0xFD);
    0x109u32.encode(sink);
}
I16x8RelaxedLaneselect => {
    sink.push(0xFD);
    0x10Au32.encode(sink);
}
I32x4RelaxedLaneselect => {
    sink.push(0xFD);
    0x10Bu32.encode(sink);
}
I64x2RelaxedLaneselect => {
    sink.push(0xFD);
    0x10Cu32.encode(sink);
}
F32x4RelaxedMin => {
    sink.push(0xFD);
    0x10Du32.encode(sink);
}
F32x4RelaxedMax => {
    sink.push(0xFD);
    0x10Eu32.encode(sink);
}
F64x2RelaxedMin => {
    sink.push(0xFD);
    0x10Fu32.encode(sink);
}
F64x2RelaxedMax => {
    sink.push(0xFD);
    0x110u32.encode(sink);
}
I16x8RelaxedQ15mulrS => {
    sink.push(0xFD);
    0x111u32.encode(sink);
}
I16x8RelaxedDotI8x16I7x16S => {
    sink.push(0xFD);
    0x112u32.encode(sink);
}
I32x4RelaxedDotI8x16I7x16AddS => {
    sink.push(0xFD);
    0x113u32.encode(sink);
}

// Atomic instructions from the thread proposal
MemoryAtomicNotify(memarg) => {
    sink.push(0xFE);
    sink.push(0x00);
    memarg.encode(sink);
}
MemoryAtomicWait32(memarg) => {
    sink.push(0xFE);
    sink.push(0x01);
    memarg.encode(sink);
}
MemoryAtomicWait64(memarg) => {
    sink.push(0xFE);
    sink.push(0x02);
    memarg.encode(sink);
}
AtomicFence => {
    sink.push(0xFE);
    sink.push(0x03);
    sink.push(0x00);
}
I32AtomicLoad(memarg) => {
    sink.push(0xFE);
    sink.push(0x10);
    memarg.encode(sink);
}
I64AtomicLoad(memarg) => {
    sink.push(0xFE);
    sink.push(0x11);
    memarg.encode(sink);
}
I32AtomicLoad8U(memarg) => {
    sink.push(0xFE);
    sink.push(0x12);
    memarg.encode(sink);
}
I32AtomicLoad16U(memarg) => {
    sink.push(0xFE);
    sink.push(0x13);
    memarg.encode(sink);
}
I64AtomicLoad8U(memarg) => {
    sink.push(0xFE);
    sink.push(0x14);
    memarg.encode(sink);
}
I64AtomicLoad16U(memarg) => {
    sink.push(0xFE);
    sink.push(0x15);
    memarg.encode(sink);
}
I64AtomicLoad32U(memarg) => {
    sink.push(0xFE);
    sink.push(0x16);
    memarg.encode(sink);
}
I32AtomicStore(memarg) => {
    sink.push(0xFE);
    sink.push(0x17);
    memarg.encode(sink);
}
I64AtomicStore(memarg) => {
    sink.push(0xFE);
    sink.push(0x18);
    memarg.encode(sink);
}
I32AtomicStore8(memarg) => {
    sink.push(0xFE);
    sink.push(0x19);
    memarg.encode(sink);
}
I32AtomicStore16(memarg) => {
    sink.push(0xFE);
    sink.push(0x1A);
    memarg.encode(sink);
}
I64AtomicStore8(memarg) => {
    sink.push(0xFE);
    sink.push(0x1B);
    memarg.encode(sink);
}
I64AtomicStore16(memarg) => {
    sink.push(0xFE);
    sink.push(0x1C);
    memarg.encode(sink);
}
I64AtomicStore32(memarg) => {
    sink.push(0xFE);
    sink.push(0x1D);
    memarg.encode(sink);
}
I32AtomicRmwAdd(memarg) => {
    sink.push(0xFE);
    sink.push(0x1E);
    memarg.encode(sink);
}
I64AtomicRmwAdd(memarg) => {
    sink.push(0xFE);
    sink.push(0x1F);
    memarg.encode(sink);
}
I32AtomicRmw8AddU(memarg) => {
    sink.push(0xFE);
    sink.push(0x20);
    memarg.encode(sink);
}
I32AtomicRmw16AddU(memarg) => {
    sink.push(0xFE);
    sink.push(0x21);
    memarg.encode(sink);
}
I64AtomicRmw8AddU(memarg) => {
    sink.push(0xFE);
    sink.push(0x22);
    memarg.encode(sink);
}
I64AtomicRmw16AddU(memarg) => {
    sink.push(0xFE);
    sink.push(0x23);
    memarg.encode(sink);
}
I64AtomicRmw32AddU(memarg) => {
    sink.push(0xFE);
    sink.push(0x24);
    memarg.encode(sink);
}
I32AtomicRmwSub(memarg) => {
    sink.push(0xFE);
    sink.push(0x25);
    memarg.encode(sink);
}
I64AtomicRmwSub(memarg) => {
    sink.push(0xFE);
    sink.push(0x26);
    memarg.encode(sink);
}
I32AtomicRmw8SubU(memarg) => {
    sink.push(0xFE);
    sink.push(0x27);
    memarg.encode(sink);
}
I32AtomicRmw16SubU(memarg) => {
    sink.push(0xFE);
    sink.push(0x28);
    memarg.encode(sink);
}
I64AtomicRmw8SubU(memarg) => {
    sink.push(0xFE);
    sink.push(0x29);
    memarg.encode(sink);
}
I64AtomicRmw16SubU(memarg) => {
    sink.push(0xFE);
    sink.push(0x2A);
    memarg.encode(sink);
}
I64AtomicRmw32SubU(memarg) => {
    sink.push(0xFE);
    sink.push(0x2B);
    memarg.encode(sink);
}
I32AtomicRmwAnd(memarg) => {
    sink.push(0xFE);
    sink.push(0x2C);
    memarg.encode(sink);
}
I64AtomicRmwAnd(memarg) => {
    sink.push(0xFE);
    sink.push(0x2D);
    memarg.encode(sink);
}
I32AtomicRmw8AndU(memarg) => {
    sink.push(0xFE);
    sink.push(0x2E);
    memarg.encode(sink);
}
I32AtomicRmw16AndU(memarg) => {
    sink.push(0xFE);
    sink.push(0x2F);
    memarg.encode(sink);
}
I64AtomicRmw8AndU(memarg) => {
    sink.push(0xFE);
    sink.push(0x30);
    memarg.encode(sink);
}
I64AtomicRmw16AndU(memarg) => {
    sink.push(0xFE);
    sink.push(0x31);
    memarg.encode(sink);
}
I64AtomicRmw32AndU(memarg) => {
    sink.push(0xFE);
    sink.push(0x32);
    memarg.encode(sink);
}
I32AtomicRmwOr(memarg) => {
    sink.push(0xFE);
    sink.push(0x33);
    memarg.encode(sink);
}
I64AtomicRmwOr(memarg) => {
    sink.push(0xFE);
    sink.push(0x34);
    memarg.encode(sink);
}
I32AtomicRmw8OrU(memarg) => {
    sink.push(0xFE);
    sink.push(0x35);
    memarg.encode(sink);
}
I32AtomicRmw16OrU(memarg) => {
    sink.push(0xFE);
    sink.push(0x36);
    memarg.encode(sink);
}
I64AtomicRmw8OrU(memarg) => {
    sink.push(0xFE);
    sink.push(0x37);
    memarg.encode(sink);
}
I64AtomicRmw16OrU(memarg) => {
    sink.push(0xFE);
    sink.push(0x38);
    memarg.encode(sink);
}
I64AtomicRmw32OrU(memarg) => {
    sink.push(0xFE);
    sink.push(0x39);
    memarg.encode(sink);
}
I32AtomicRmwXor(memarg) => {
    sink.push(0xFE);
    sink.push(0x3A);
    memarg.encode(sink);
}
I64AtomicRmwXor(memarg) => {
    sink.push(0xFE);
    sink.push(0x3B);
    memarg.encode(sink);
}
I32AtomicRmw8XorU(memarg) => {
    sink.push(0xFE);
    sink.push(0x3C);
    memarg.encode(sink);
}
I32AtomicRmw16XorU(memarg) => {
    sink.push(0xFE);
    sink.push(0x3D);
    memarg.encode(sink);
}
I64AtomicRmw8XorU(memarg) => {
    sink.push(0xFE);
    sink.push(0x3E);
    memarg.encode(sink);
}
I64AtomicRmw16XorU(memarg) => {
    sink.push(0xFE);
    sink.push(0x3F);
    memarg.encode(sink);
}
I64AtomicRmw32XorU(memarg) => {
    sink.push(0xFE);
    sink.push(0x40);
    memarg.encode(sink);
}
I32AtomicRmwXchg(memarg) => {
    sink.push(0xFE);
    sink.push(0x41);
    memarg.encode(sink);
}
I64AtomicRmwXchg(memarg) => {
    sink.push(0xFE);
    sink.push(0x42);
    memarg.encode(sink);
}
I32AtomicRmw8XchgU(memarg) => {
    sink.push(0xFE);
    sink.push(0x43);
    memarg.encode(sink);
}
I32AtomicRmw16XchgU(memarg) => {
    sink.push(0xFE);
    sink.push(0x44);
    memarg.encode(sink);
}
I64AtomicRmw8XchgU(memarg) => {
    sink.push(0xFE);
    sink.push(0x45);
    memarg.encode(sink);
}
I64AtomicRmw16XchgU(memarg) => {
    sink.push(0xFE);
    sink.push(0x46);
    memarg.encode(sink);
}
I64AtomicRmw32XchgU(memarg) => {
    sink.push(0xFE);
    sink.push(0x47);
    memarg.encode(sink);
}
I32AtomicRmwCmpxchg(memarg) => {
    sink.push(0xFE);
    sink.push(0x48);
    memarg.encode(sink);
}
I64AtomicRmwCmpxchg(memarg) => {
    sink.push(0xFE);
    sink.push(0x49);
    memarg.encode(sink);
}
I32AtomicRmw8CmpxchgU(memarg) => {
    sink.push(0xFE);
    sink.push(0x4A);
    memarg.encode(sink);
}
I32AtomicRmw16CmpxchgU(memarg) => {
    sink.push(0xFE);
    sink.push(0x4B);
    memarg.encode(sink);
}
I64AtomicRmw8CmpxchgU(memarg) => {
    sink.push(0xFE);
    sink.push(0x4C);
    memarg.encode(sink);
}
I64AtomicRmw16CmpxchgU(memarg) => {
    sink.push(0xFE);
    sink.push(0x4D);
    memarg.encode(sink);
}
I64AtomicRmw32CmpxchgU(memarg) => {
    sink.push(0xFE);
    sink.push(0x4E);
    memarg.encode(sink);
}

// Atomic instructions from the shared-everything-threads proposal
GlobalAtomicGet { ordering, global_index } => {
    sink.push(0xFE);
    sink.push(0x4F);
    ordering.encode(sink);
    global_index.encode(sink);
}
GlobalAtomicSet { ordering, global_index } => {
    sink.push(0xFE);
    sink.push(0x50);
    ordering.encode(sink);
    global_index.encode(sink);
}
GlobalAtomicRmwAdd { ordering, global_index } => {
    sink.push(0xFE);
    sink.push(0x51);
    ordering.encode(sink);
    global_index.encode(sink);
}
GlobalAtomicRmwSub { ordering, global_index } => {
    sink.push(0xFE);
    sink.push(0x52);
    ordering.encode(sink);
    global_index.encode(sink);
}
GlobalAtomicRmwAnd { ordering, global_index } => {
    sink.push(0xFE);
    sink.push(0x53);
    ordering.encode(sink);
    global_index.encode(sink);
}
GlobalAtomicRmwOr { ordering, global_index } => {
    sink.push(0xFE);
    sink.push(0x54);
    ordering.encode(sink);
    global_index.encode(sink);
}
GlobalAtomicRmwXor { ordering, global_index } => {
    sink.push(0xFE);
    sink.push(0x55);
    ordering.encode(sink);
    global_index.encode(sink);
}
GlobalAtomicRmwXchg { ordering, global_index } => {
    sink.push(0xFE);
    sink.push(0x56);
    ordering.encode(sink);
    global_index.encode(sink);
}
GlobalAtomicRmwCmpxchg { ordering, global_index } => {
    sink.push(0xFE);
    sink.push(0x57);
    ordering.encode(sink);
    global_index.encode(sink);
}
TableAtomicGet { ordering, table_index } => {
    sink.push(0xFE);
    sink.push(0x58);
    ordering.encode(sink);
    table_index.encode(sink);
}
TableAtomicSet { ordering, table_index } => {
    sink.push(0xFE);
    sink.push(0x59);
    ordering.encode(sink);
    table_index.encode(sink);
}
TableAtomicRmwXchg { ordering, table_index } => {
    sink.push(0xFE);
    sink.push(0x5A);
    ordering.encode(sink);
    table_index.encode(sink);
}
TableAtomicRmwCmpxchg { ordering, table_index } => {
    sink.push(0xFE);
    sink.push(0x5B);
    ordering.encode(sink);
    table_index.encode(sink);
}
StructAtomicGet { ordering, struct_type_index, field_index } => {
    sink.push(0xFE);
    sink.push(0x5C);
    ordering.encode(sink);
    struct_type_index.encode(sink);
    field_index.encode(sink);
}
StructAtomicGetS { ordering, struct_type_index, field_index } => {
    sink.push(0xFE);
    sink.push(0x5D);
    ordering.encode(sink);
    struct_type_index.encode(sink);
    field_index.encode(sink);
}
StructAtomicGetU { ordering, struct_type_index, field_index } => {
    sink.push(0xFE);
    sink.push(0x5E);
    ordering.encode(sink);
    struct_type_index.encode(sink);
    field_index.encode(sink);
}
StructAtomicSet { ordering, struct_type_index, field_index } => {
    sink.push(0xFE);
    sink.push(0x5F);
    ordering.encode(sink);
    struct_type_index.encode(sink);
    field_index.encode(sink);
}
StructAtomicRmwAdd { ordering, struct_type_index, field_index } => {
    sink.push(0xFE);
    sink.push(0x60);
    ordering.encode(sink);
    struct_type_index.encode(sink);
    field_index.encode(sink);
}
StructAtomicRmwSub { ordering, struct_type_index, field_index } => {
    sink.push(0xFE);
    sink.push(0x61);
    ordering.encode(sink);
    struct_type_index.encode(sink);
    field_index.encode(sink);
}
StructAtomicRmwAnd { ordering, struct_type_index, field_index } => {
    sink.push(0xFE);
    sink.push(0x62);
    ordering.encode(sink);
    struct_type_index.encode(sink);
    field_index.encode(sink);
}
StructAtomicRmwOr { ordering, struct_type_index, field_index } => {
    sink.push(0xFE);
    sink.push(0x63);
    ordering.encode(sink);
    struct_type_index.encode(sink);
    field_index.encode(sink);
}
StructAtomicRmwXor { ordering, struct_type_index, field_index } => {
    sink.push(0xFE);
    sink.push(0x64);
    ordering.encode(sink);
    struct_type_index.encode(sink);
    field_index.encode(sink);
}
StructAtomicRmwXchg { ordering, struct_type_index, field_index } => {
    sink.push(0xFE);
    sink.push(0x65);
    ordering.encode(sink);
    struct_type_index.encode(sink);
    field_index.encode(sink);
}
StructAtomicRmwCmpxchg { ordering, struct_type_index, field_index } => {
    sink.push(0xFE);
    sink.push(0x66);
    ordering.encode(sink);
    struct_type_index.encode(sink);
    field_index.encode(sink);
}
ArrayAtomicGet { ordering, array_type_index } => {
    sink.push(0xFE);
    sink.push(0x67);
    ordering.encode(sink);
    array_type_index.encode(sink);
}
ArrayAtomicGetS { ordering, array_type_index } => {
    sink.push(0xFE);
    sink.push(0x68);
    ordering.encode(sink);
    array_type_index.encode(sink);
}
ArrayAtomicGetU { ordering, array_type_index } => {
    sink.push(0xFE);
    sink.push(0x69);
    ordering.encode(sink);
    array_type_index.encode(sink);
}
ArrayAtomicSet { ordering, array_type_index } => {
    sink.push(0xFE);
    sink.push(0x6A);
    ordering.encode(sink);
    array_type_index.encode(sink);
}
ArrayAtomicRmwAdd { ordering, array_type_index } => {
    sink.push(0xFE);
    sink.push(0x6B);
    ordering.encode(sink);
    array_type_index.encode(sink);
}
ArrayAtomicRmwSub { ordering, array_type_index } => {
    sink.push(0xFE);
    sink.push(0x6C);
    ordering.encode(sink);
    array_type_index.encode(sink);
}
ArrayAtomicRmwAnd { ordering, array_type_index } => {
    sink.push(0xFE);
    sink.push(0x6D);
    ordering.encode(sink);
    array_type_index.encode(sink);
}
ArrayAtomicRmwOr { ordering, array_type_index } => {
    sink.push(0xFE);
    sink.push(0x6E);
    ordering.encode(sink);
    array_type_index.encode(sink);
}
ArrayAtomicRmwXor { ordering, array_type_index } => {
    sink.push(0xFE);
    sink.push(0x6F);
    ordering.encode(sink);
    array_type_index.encode(sink);
}
ArrayAtomicRmwXchg { ordering, array_type_index } => {
    sink.push(0xFE);
    sink.push(0x70);
    ordering.encode(sink);
    array_type_index.encode(sink);
}
ArrayAtomicRmwCmpxchg { ordering, array_type_index } => {
    sink.push(0xFE);
    sink.push(0x71);
    ordering.encode(sink);
    array_type_index.encode(sink);
}
RefI31Shared => {
    sink.push(0xFE);
    sink.push(0x72);
}
ContNew(type_index) => {
    sink.push(0xE0);
    type_index.encode(sink);
}
ContBind { argument_index, result_index } => {
    sink.push(0xE1);
    argument_index.encode(sink);
    result_index.encode(sink);
}
Suspend(tag_index) => {
    sink.push(0xE2);
    tag_index.encode(sink);
}
Resume { cont_type_index, ref resume_table } => {
    sink.push(0xE3);
    cont_type_index.encode(sink);
    resume_table.encode(sink);
}
ResumeThrow { cont_type_index, tag_index, ref resume_table } => {
    sink.push(0xE4);
    cont_type_index.encode(sink);
    tag_index.encode(sink);
    resume_table.encode(sink);
}
Switch { cont_type_index, tag_index } => {
    sink.push(0xE5);
    cont_type_index.encode(sink);
    tag_index.encode(sink);
}
I64Add128 => {
    sink.push(0xFC);
    19u32.encode(sink);
}
I64Sub128 => {
    sink.push(0xFC);
    20u32.encode(sink);
}
I64MulWideS => {
    sink.push(0xFC);
    21u32.encode(sink);
}
I64MulWideU => {
    sink.push(0xFC);
    22u32.encode(sink);
}
